"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VCRSession = void 0;
const eventEmitter_js_1 = require("../providers/events/eventEmitter.js");
const logContext_js_1 = require("../providers/logger/contracts/logContext.js");
const logger_js_1 = require("../providers/logger/logger.js");
const logLevel_js_1 = require("../providers/logger/enums/logLevel.js");
const wrappedCallback_js_1 = require("./contracts/wrappedCallback.js");
const dataType_js_1 = require("../request/enums/dataType.js");
class VCRSession {
    constructor(bridge, config, jwt, id) {
        this.bridge = bridge;
        this.config = config;
        this.jwt = jwt;
        this.id = id;
        this.eventEmitter = new eventEmitter_js_1.EventEmitter(this);
        this.logger = new logger_js_1.Logger(this);
    }
    emitSessionCreatedEvent(ttl) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.eventEmitter.emitSessionCreatedEvent(ttl);
        });
    }
    createUUID() {
        return this.bridge.uuid();
    }
    getToken() {
        return this.jwt.getToken();
    }
    log(level, message, context = null) {
        if (this.config.logsSubmission == false) {
            this.bridge.log("Skipping sending logs as config.logsSubmission is set to false");
        }
        else if (this.bridge.getEnv("SKIP_LOGS_SUBMISSION") == "true") {
            this.bridge.log("Skipping sending logs as SKIP_LOGS_SUBMISSION is set to true");
        }
        else {
            this.bridge.runBackgroundTask(this.logger.log(level, message, context));
        }
    }
    wrapCallback(route, filters) {
        const wrappedCallback = new wrappedCallback_js_1.WrappedCallback();
        wrappedCallback.filters = filters;
        wrappedCallback.id = this.createUUID();
        wrappedCallback.instanceServiceName = this.config.instanceServiceName;
        wrappedCallback.sessionId = this.id;
        wrappedCallback.instanceId = this.config.instanceId;
        wrappedCallback.path = route;
        return wrappedCallback;
    }
    constructCommandHeaders() {
        const headers = {};
        headers["traceId"] = this.createUUID();
        headers["instanceId"] = this.config.instanceId;
        headers["sessionId"] = this.id;
        headers["apiAccountId"] = this.config.apiAccountId;
        headers["apiApplicationId"] = this.config.apiApplicationId;
        headers["applicationName"] = this.config.instanceServiceName;
        headers["applicationId"] = this.config.applicationId;
        return headers;
    }
    constructRequestHeaders() {
        const headers = {};
        headers["X-Neru-SessionId"] = this.id;
        headers["X-Neru-ApiAccountId"] = this.config.apiAccountId;
        headers["X-Neru-ApiApplicationId"] = this.config.apiApplicationId;
        headers["X-Neru-InstanceId"] = this.config.instanceId;
        headers["X-Neru-TraceId"] = this.bridge.uuid();
        headers["Content-Type"] = "application/json";
        const token = this.getToken();
        if (token != null) {
            headers["Authorization"] = `Bearer ${token}`;
        }
        return headers;
    }
    request(params) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const result = yield this.bridge.request(params);
                if (params.responseType == "stream" /* RESPONSE_TYPE.STREAM */) {
                    this.logStreamResponse(params);
                }
                else if (params.dataType == dataType_js_1.DATA_TYPE.FORM_DATA) {
                    this.logFormData(params, result);
                }
                else {
                    this.logResponse(params, result);
                }
                return result;
            }
            catch (e) {
                this.logError(params, this.bridge.getErrorMessage(e));
                throw e;
            }
        });
    }
    logStreamResponse(params) {
        const context = new logContext_js_1.LogContext(params.url, null, "Stream response received");
        this.log(logLevel_js_1.LOG_LEVEL.INFO, `Sending ${params.method} to ${params.url}`, context);
    }
    logFormData(params, result) {
        const context = new logContext_js_1.LogContext(params.url, "form-data is sent", this.bridge.jsonStringify(result));
        this.log(logLevel_js_1.LOG_LEVEL.INFO, `Sending ${params.method} to ${params.url}`, context);
    }
    logResponse(params, result) {
        const context = new logContext_js_1.LogContext(params.url, this.bridge.jsonStringify(params.data), this.bridge.jsonStringify(result));
        this.log(logLevel_js_1.LOG_LEVEL.INFO, `Sending ${params.method} to ${params.url}`, context);
    }
    logError(params, message) {
        const context = new logContext_js_1.LogContext(params.url, this.bridge.jsonStringify(params.data), message);
        this.log(logLevel_js_1.LOG_LEVEL.ERROR, `Error while sending a ${params.method} request to ${params.url}`, context);
    }
}
exports.VCRSession = VCRSession;
//# sourceMappingURL=vcrSession.js.map