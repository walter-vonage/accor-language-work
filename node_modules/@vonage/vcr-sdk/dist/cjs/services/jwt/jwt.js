"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JWT = void 0;
const acl_js_1 = require("./contracts/acl.js");
const vcrJWTPayload_js_1 = require("./contracts/vcrJWTPayload.js");
const vonageJWTPayload_js_1 = require("./contracts/vonageJWTPayload.js");
const algorithm_js_1 = require("./enums/algorithm.js");
class JWT {
    constructor(bridge, config) {
        this._token = null;
        this.ttl = 300; // 5 minutes
        this.bridge = bridge;
        this.config = config;
    }
    /**
     * Returns a token if it is not expired, otherwise it generates a new token
     * @returns {string} JWT token that is used to authenticate with the NERU Providers API
     */
    getToken() {
        try {
            if (this._token == null || this.isExpired()) {
                const exp = this.bridge.getSystemTime() + this.ttl;
                this._token = this.createVCRToken(exp);
            }
            return this._token;
        }
        catch (e) {
            throw this.bridge.createSdkError("getToken:" + this.bridge.getErrorMessage(e));
        }
    }
    /**
     *
     * @returns {boolean} True if the token is expired 20 seconds from now, otherwise false
     */
    isExpired() {
        const nowInSeconds = this.bridge.getSystemTime();
        const twentySeconds = 20;
        const payload = this.bridge.jwtDecode(this._token);
        return payload.exp - twentySeconds <= nowInSeconds;
    }
    /**
     * Generate a JWT token that is used to authenticate with the NERU Providers API
     * @param exp Expire time in seconds since epoch
     * @returns {string} JWT token that is used to authenticate with the NERU Providers API
     */
    createVCRToken(exp) {
        const p = new vcrJWTPayload_js_1.VCRJWTPayload();
        p.api_application_id = this.config.apiApplicationId;
        p.api_account_id = this.config.apiAccountId;
        p.exp = exp;
        p.sub = this.config.instanceServiceName;
        return this.bridge.jwtSign(p, this.config.privateKey, algorithm_js_1.ALGORITHM.RS256);
    }
    /**
     * Generate a JWT token that is used to authenticate with Vonage APIs
     * @param params
     * @param {number} params.exp - Expire time in seconds since epoch
     * @param {Record<string, any>=} params.aclPaths - ACL paths to add to the token
     * @param {string=} params.subject - Subject to add to the token
     * @returns {string} - JWT Token
     */
    createVonageToken(params) {
        const jwtPayload = new vonageJWTPayload_js_1.VonageJWTPayload();
        jwtPayload.iat = this.bridge.getSystemTime();
        jwtPayload.exp = params.exp;
        jwtPayload.application_id = this.config.apiApplicationId;
        jwtPayload.jti = this.bridge.uuid();
        if (params.aclPaths) {
            jwtPayload.acl = new acl_js_1.Acl();
            jwtPayload.acl.paths = params.aclPaths;
        }
        if (params.subject) {
            jwtPayload.sub = params.subject;
        }
        return this.bridge.jwtSign(jwtPayload, this.config.privateKey, algorithm_js_1.ALGORITHM.RS256);
    }
}
exports.JWT = JWT;
//# sourceMappingURL=jwt.js.map