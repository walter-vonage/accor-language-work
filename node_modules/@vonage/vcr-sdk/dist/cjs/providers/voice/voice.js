"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Voice = void 0;
const voiceAction_js_1 = require("./enums/voiceAction.js");
const callAnswerCallBack_js_1 = require("./contracts/callAnswerCallBack.js");
const CallEventCallBackPayload_js_1 = require("./contracts/CallEventCallBackPayload.js");
const requestParams_js_1 = require("../../request/contracts/requestParams.js");
const createVonageTokenParams_js_1 = require("../../services/jwt/contracts/createVonageTokenParams.js");
const assets_js_1 = require("../assets/assets.js");
const requestVerb_js_1 = require("../../request/enums/requestVerb.js");
class Voice {
    constructor(session) {
        this.provider = "vonage-voice";
        this.session = session;
        this.bridge = session.bridge;
        this.assetsAPI = new assets_js_1.Assets(session);
    }
    onCall(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestParams = new requestParams_js_1.RequestParams();
            requestParams.method = requestVerb_js_1.REQUEST_VERB.POST;
            requestParams.data = new callAnswerCallBack_js_1.CallAnswerCallBack(this.session.wrapCallback(callback, []));
            requestParams.headers = this.session.constructRequestHeaders();
            requestParams.url = this.session.config.getExecutionUrl(this.provider, voiceAction_js_1.VOICE_ACTION.VAPI_SUBSCRIBE_INBOUND_CALL);
            yield this.session.request(requestParams);
            return requestParams.data.callback.id;
        });
    }
    onCallEvent(params) {
        return __awaiter(this, void 0, void 0, function* () {
            let payload = new CallEventCallBackPayload_js_1.CallEventCallBackPayload();
            payload.callback = this.session.wrapCallback(params.callback, []);
            if (params.vapiID != null) {
                payload.vapiId = params.vapiID;
            }
            else if (params.conversationID != null) {
                payload.conversationId = params.conversationID;
            }
            const requestParams = new requestParams_js_1.RequestParams();
            requestParams.method = requestVerb_js_1.REQUEST_VERB.POST;
            requestParams.data = payload;
            requestParams.headers = this.session.constructRequestHeaders();
            requestParams.url = this.session.config.getExecutionUrl(this.provider, voiceAction_js_1.VOICE_ACTION.VAPI_SUBSCRIBE_EVENT);
            yield this.session.request(requestParams);
            return payload.callback.id;
        });
    }
    getCallRecording(recordingUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            const tp = new createVonageTokenParams_js_1.CreateVonageTokenParams();
            tp.exp = this.bridge.getSystemTime() + 60 * 60;
            const t = this.session.jwt.createVonageToken(tp);
            const rp = new requestParams_js_1.RequestParams();
            rp.method = requestVerb_js_1.REQUEST_VERB.GET;
            rp.url = recordingUrl;
            rp.headers = {};
            rp.headers["Authorization"] = `Bearer ${t}`;
            rp.responseType = "stream" /* RESPONSE_TYPE.STREAM */;
            return yield this.session.request(rp);
        });
    }
    uploadCallRecording(recordingUrl, assetsPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const stream = yield this.getCallRecording(recordingUrl);
            const pathObject = this.bridge.parsePath(assetsPath);
            const data = [stream];
            const fileNames = [pathObject.base];
            return yield this.assetsAPI.uploadData(data, pathObject.dir, fileNames);
        });
    }
}
exports.Voice = Voice;
//# sourceMappingURL=voice.js.map