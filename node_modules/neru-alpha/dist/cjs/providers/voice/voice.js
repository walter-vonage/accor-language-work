"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Voice = void 0;
const conversation_js_1 = require("./conversation.js");
const vonageAPI_js_1 = require("../vonageAPI/vonageAPI.js");
const actionPayload_js_1 = require("../../session/actionPayload.js");
const voiceActions_js_1 = require("./voiceActions.js");
const requestInterfaceForCallbacks_js_1 = require("../../session/requestInterfaceForCallbacks.js");
const createConversationPayload_js_1 = require("./contracts/createConversationPayload.js");
const vapiAnswerCallBack_js_1 = require("./contracts/vapiAnswerCallBack.js");
const vapiEventCallBackPayload_js_1 = require("./contracts/vapiEventCallBackPayload.js");
const vapiCreateCallPayload_js_1 = require("./contracts/vapiCreateCallPayload.js");
const onInboundCallPayload_js_1 = require("./contracts/onInboundCallPayload.js");
const requestParams_js_1 = require("../../request/requestParams.js");
const createVonageTokenParams_js_1 = require("../../services/jwt/createVonageTokenParams.js");
const assets_js_1 = require("../assets/assets.js");
const requestMethods_js_1 = require("../../request/requestMethods.js");
class Voice {
    constructor(session, regionURL = null) {
        this.provider = "vonage-voice";
        this.regionURL = "https://api.nexmo.com";
        this.session = session;
        this.bridge = session.bridge;
        this.assetsAPI = new assets_js_1.Assets(session);
        this.vonageApi = new vonageAPI_js_1.VonageAPI(this.session);
        if (regionURL != null) {
            this.regionURL = regionURL;
        }
    }
    onInboundCall(callback, to, from = null) {
        if (to.type == null) {
            to.type = "phone";
        }
        if (from != null && from.type == null) {
            from.type = "phone";
        }
        const payload = new onInboundCallPayload_js_1.OnInboundCallPayload(this.session.wrapCallback(callback, []), to, from);
        const action = new actionPayload_js_1.ActionPayload(this.provider, voiceActions_js_1.VoiceActions.ConversationSubscribeInboundCall, payload);
        return new requestInterfaceForCallbacks_js_1.RequestInterfaceForCallbacks(this.session, action);
    }
    createConversation(name = null, displayName = null) {
        return __awaiter(this, void 0, void 0, function* () {
            var conversationName = name;
            var conversationDisplayName = displayName;
            if (name == null) {
                const conversationId = this.bridge.substring(this.session.createUUID(), 0, 5);
                conversationName = `name_cs_${conversationId}`;
            }
            if (displayName == null) {
                conversationDisplayName = `dn_${conversationName};`;
            }
            const payload = new createConversationPayload_js_1.CreateConversationPayload(conversationName, conversationDisplayName);
            const url = "https://api.nexmo.com/v0.3/conversations";
            const method = requestMethods_js_1.RequestMethods.POST;
            const res = yield this.vonageApi
                .invoke(url, method, payload)
                .execute();
            return new conversation_js_1.Conversation(res.id, this.session);
        });
    }
    onVapiAnswer(callback) {
        const payload = new vapiAnswerCallBack_js_1.VapiAnswerCallBack(this.session.wrapCallback(callback, []));
        const action = new actionPayload_js_1.ActionPayload(this.provider, voiceActions_js_1.VoiceActions.VapiSubscribeInboundCall, payload);
        return new requestInterfaceForCallbacks_js_1.RequestInterfaceForCallbacks(this.session, action);
    }
    onVapiEvent(params) {
        let payload = new vapiEventCallBackPayload_js_1.VapiEventCallBackPayload();
        payload.callback = this.session.wrapCallback(params.callback, []);
        if (params.conversationID == null && params.vapiUUID == null) {
            throw new Error("Either conversationID or vapiUUID is required");
        }
        if (params.vapiUUID != null) {
            payload.vapiID = params.vapiUUID;
        }
        else if (params.conversationID != null) {
            payload.conversationID = params.conversationID;
        }
        const action = new actionPayload_js_1.ActionPayload(this.provider, voiceActions_js_1.VoiceActions.VapiSubscribeEvent, payload);
        return new requestInterfaceForCallbacks_js_1.RequestInterfaceForCallbacks(this.session, action);
    }
    vapiCreateCall(from, to, ncco, options) {
        const vapiCreateCallPayload = new vapiCreateCallPayload_js_1.VapiCreateCallPayload(from, to, ncco, options);
        const method = requestMethods_js_1.RequestMethods.POST;
        return this.vonageApi.invoke(`${this.regionURL}/v1/calls`, method, vapiCreateCallPayload);
    }
    uploadNCCO(uuid, ncco) {
        const method = requestMethods_js_1.RequestMethods.PUT;
        return this.vonageApi.invoke(`${this.regionURL}/v1/calls/${uuid}`, method, ncco);
    }
    getConversation(id) {
        return new conversation_js_1.Conversation(id, this.session);
    }
    getCallRecording(recordingUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = new requestParams_js_1.RequestParams();
            params.method = requestMethods_js_1.RequestMethods.GET;
            params.url = recordingUrl;
            const createVonageTokenParams = new createVonageTokenParams_js_1.CreateVonageTokenParams();
            createVonageTokenParams.exp = this.bridge.getSystemTime() + 60 * 60;
            const token = this.session.jwt.createVonageToken(createVonageTokenParams);
            const headers = {};
            headers["Authorization"] = `Bearer ${token}`;
            params.headers = headers;
            params.responseType = "stream" /* ResponseTypes.STREAM */;
            return yield this.bridge.request(params);
        });
    }
    uploadCallRecording(recordingUrl, assetsPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const stream = yield this.getCallRecording(recordingUrl);
            const pathObject = this.bridge.parsePath(assetsPath);
            const data = [stream];
            const fileNames = [pathObject.base];
            yield this.assetsAPI.uploadData(data, pathObject.dir, fileNames).execute();
        });
    }
}
exports.Voice = Voice;
//# sourceMappingURL=voice.js.map