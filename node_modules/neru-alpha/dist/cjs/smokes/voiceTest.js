"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VoiceSmokeTests = void 0;
const voice_js_1 = require("../providers/voice/voice.js");
const vapiEventParams_js_1 = require("../providers/voice/contracts/vapiEventParams.js");
const neru_js_1 = require("../neru.js");
const channelPhoneEndpoint_js_1 = require("../providers/voice/contracts/channelPhoneEndpoint.js");
const state_js_1 = require("../providers/state/state.js");
const requestParams_js_1 = require("../request/requestParams.js");
const bridge_js_1 = require("../bridge.js");
class VoiceSmokeTests {
    constructor() {
        this.bridge = new bridge_js_1.Bridge();
        this.neru = new neru_js_1.Neru();
        this.session = this.neru.createSession();
        this.voice = new voice_js_1.Voice(this.session);
        this.state = new state_js_1.State(this.session);
        this.events = [];
    }
    checkIncomingEventsAndHitHealthEndpointIfSuccessful(status, successPathname) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.state.incrby(status, 1);
            const started = yield this.state.get("started");
            const ringing = yield this.state.get("ringing");
            const answered = yield this.state.get("answered");
            const completed = yield this.state.get("completed");
            const allEventsReceived = started && ringing && answered && completed;
            if (allEventsReceived) {
                // all events have been received
                const requestParams = new requestParams_js_1.RequestParams();
                requestParams.method = "POST";
                requestParams.url = `https://hc-ping.com/${successPathname}`;
                yield this.bridge.requestWithoutResponse(requestParams);
                this.events = [];
            }
            return;
        });
    }
    answer(event) {
        return __awaiter(this, void 0, void 0, function* () {
            const conversation = yield this.voice.createConversation();
            yield conversation.acceptInboundCall(event).execute();
            yield conversation.sayText({ text: "Hello from Vonage!" }).execute();
        });
    }
    onInboundCall(callback, to) {
        return __awaiter(this, void 0, void 0, function* () {
            const vonageNumber = new channelPhoneEndpoint_js_1.ChannelPhoneEndpoint(to);
            yield this.voice.onInboundCall(callback, vonageNumber).execute();
        });
    }
    call(fromNumber, toNumber, eventCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            const _fromNumber = new channelPhoneEndpoint_js_1.ChannelPhoneEndpoint(fromNumber);
            const _toNumber = new channelPhoneEndpoint_js_1.ChannelPhoneEndpoint(toNumber);
            const toNumbers = [_toNumber];
            const nccoActions = [
                {
                    action: "talk",
                    text: "Hello from Vonage! Listening for DTMF input...",
                },
                {
                    action: "input",
                    type: ["dtmf"],
                    dtmf: {
                        maxDigits: 1,
                        submitOnHash: true,
                        timeOut: 10,
                    },
                },
            ];
            const response = yield this.voice.vapiCreateCall(_fromNumber, toNumbers, nccoActions).execute();
            const onEventParams = new vapiEventParams_js_1.VapiEventParams();
            onEventParams.callback = eventCallback;
            onEventParams.vapiUUID = response.uuid;
            yield this.voice.onVapiEvent(onEventParams).execute();
        });
    }
}
exports.VoiceSmokeTests = VoiceSmokeTests;
//# sourceMappingURL=voiceTest.js.map