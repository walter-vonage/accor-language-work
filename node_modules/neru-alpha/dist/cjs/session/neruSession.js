"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NeruSession = void 0;
const eventEmitter_js_1 = require("../providers/events/eventEmitter.js");
const logContext_js_1 = require("../providers/logger/logContext.js");
const logger_js_1 = require("../providers/logger/logger.js");
const logLevels_js_1 = require("../providers/logger/logLevels.js");
const command_js_1 = require("./command.js");
const wrappedCallback_js_1 = require("./wrappedCallback.js");
class NeruSession {
    constructor(commandService, bridge, config, jwt, id) {
        this.commandService = commandService;
        this.id = id;
        this.bridge = bridge;
        this.config = config;
        this.jwt = jwt;
        this.eventEmitter = new eventEmitter_js_1.EventEmitter(this);
        this.logger = new logger_js_1.Logger(this);
    }
    emitSessionCreatedEvent(ttl) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.eventEmitter.emitSessionCreatedEvent(ttl);
        });
    }
    createUUID() {
        return this.bridge.uuid();
    }
    getToken() {
        if (this.config.debug) {
            return null;
        }
        return this.jwt.getToken();
    }
    log(level, message, context = null) {
        if (this.config.logsSubmission == false) {
            this.bridge.log("Skipping sending logs as config.logsSubmission is set to false");
        }
        else if (this.bridge.getEnv("SKIP_LOGS_SUBMISSION") == "true") {
            this.bridge.log("Skipping sending logs as SKIP_LOGS_SUBMISSION is set to true");
        }
        else {
            this.bridge.runBackgroundTask(this.logger.log(level, message, context));
        }
    }
    wrapCallback(route, filters) {
        const wrappedCallback = new wrappedCallback_js_1.WrappedCallback();
        wrappedCallback.filters = filters;
        wrappedCallback.id = this.createUUID();
        wrappedCallback.instanceServiceName = this.config.instanceServiceName;
        wrappedCallback.sessionId = this.id;
        wrappedCallback.instanceId = this.config.instanceId;
        wrappedCallback.path = route;
        return wrappedCallback;
    }
    constructCommandHeaders() {
        const headers = {};
        headers["traceId"] = this.createUUID();
        headers["instanceId"] = this.config.instanceId;
        headers["sessionId"] = this.id;
        headers["apiAccountId"] = this.config.apiAccountId;
        headers["apiApplicationId"] = this.config.apiApplicationId;
        headers["applicationName"] = this.config.instanceServiceName;
        headers["applicationId"] = this.config.applicationId;
        return headers;
    }
    constructRequestHeaders() {
        const headers = {};
        headers["X-Neru-SessionId"] = this.id;
        headers["X-Neru-ApiAccountId"] = this.config.apiAccountId;
        headers["X-Neru-ApiApplicationId"] = this.config.apiApplicationId;
        headers["X-Neru-InstanceId"] = this.config.instanceId;
        headers["X-Neru-TraceId"] = this.bridge.uuid();
        headers["Content-Type"] = "application/json";
        const token = this.getToken();
        if (token != null) {
            headers["Authorization"] = `Bearer ${token}`;
        }
        return headers;
    }
    executeAction(actionPayload, method) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const commandHeaders = this.constructCommandHeaders();
                const requestHeaders = this.constructRequestHeaders();
                const payload = new command_js_1.Command(commandHeaders, actionPayload);
                const url = this.config.getExecutionUrl(actionPayload.provider);
                const result = yield this.commandService.executeCommand(url, method, payload, requestHeaders);
                const context = new logContext_js_1.LogContext(actionPayload.action, this.bridge.jsonStringify(actionPayload.payload), this.bridge.jsonStringify(result));
                this.log(logLevels_js_1.LogLevels.info, `Executing action: ${actionPayload.action}, provider: ${actionPayload.provider}`, context);
                return result;
            }
            catch (e) {
                const context = new logContext_js_1.LogContext(actionPayload.action, this.bridge.jsonStringify(actionPayload.payload), e.message);
                this.log(logLevels_js_1.LogLevels.error, `Error while executing action: ${actionPayload.action}, provider: ${actionPayload.provider}`, context);
                throw e;
            }
        });
    }
}
exports.NeruSession = NeruSession;
//# sourceMappingURL=neruSession.js.map